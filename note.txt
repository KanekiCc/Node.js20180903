前后端分离：
1.前端创建数据，不需要等待后台
2.前端可以发布项目   ftp    filezilla
各司其职
----------------------------------------------------------------------------------------------------
$.ajax({
      url:"127.0.0.1:3000/login",
      type:"post",    // get post  put  delete  push  options
      data:{
          username:"",
          password:""
      },
      dataType:"json",
      async:"false"
      })

      window.location.href
      hash  #  跳转
      search  ?
      port  端口
      path  路径
      pathName
      host   主域

------------------------------------------------------------------------------------------
node

npm  node.js的包管理工具

npm install -g cnpm
--registry=http://registry.npm.taobao.org
淘宝镜像
缺点：容易丢失文件
优点：下载速度快

nrm    npm的管理工具
nrm use 管理名称  可以自由切换
作用：可以自由选择包管理工具


node -v
npm  -v
npm install nrm -g                  install 安装依赖    g  global 全局
nrm -V  /  nrm--version
nrm ls
nrm use 管理名称  可以自由切换

------------------------------------------------------------------------------------------
node 特点
单线程
非阻塞I/O
事件驱动

程序  进程   线程
程序 由源代码生成的可执行应用。
进程 一个正在运行的程序可以看作一个进程  进程拥有独立运行所需要的全部资源
线程 程序中独立运行的代码段

一个进程是由一个或多个线程组成，进程只负责资源的调度和分配，线程才是程序真正的执行单元，负责代码的执行

------------------------------------------------------------------------------------------
单线程

每个正在运行的程序（即进程），至少包括一个线程，这个线程叫主线程

主线程在程序启动时被创建，用于执行main函数

只有一个主线程的程序，称作单线程程序

主线程负责执行程序的所有代码（UI展现以及刷新，网络请求，本地存储等等）。这些代码只能顺序执行，无法并发执行

------------------------------------------------------------------------------------------
单线程 多线程的区别

单线程程序：只有一个线程，代码顺序执行，容易出现代码阻塞（页面假死）

多线程程序：有多个线程，线程间独立运行，能有效的避免代码阻塞，并提高程序的运行性能

注意：ios中关于UI的添加和刷新必须在主线程中操作
------------------------------------------------------------------------------------------
阻塞式IO：IO即input/output，阻塞式IO指的是 一旦输入/输出工作没有完成，则程序阻塞，直到输入/输出工作完成

非阻塞式IO：
非阻塞式IO其实也并非完全非阻塞，通常都是通过设置超时来读取数据的。未超时之前，程序阻塞在读写函数上；
超时后，结束本次读取，将已读到的数据返回。通过不断循环读取，就能够读取完整数据了。
如果多次连续超时读到空数据的话，则可以断开

非阻塞IO缺点：
造成资源浪费
（如果你企图保持socket的长链接，server在规定的时间内没有读到client的心跳，
然而你server读取socket传来的数据。
调用的输入函数是阻塞式IO，那么即便client断开连接，
你的sever程序仍然会被阻塞在该输入函数下无法继续等待数据结束标志，比如换行符。
然而由于client已经断开连接，所以server永远收不到数据，这个线程就卡在这里结束不了）
------------------------------------------------------------------------------------------
status code  状态码
 '100': 'Continue',  客户端应当继续发送请求。
 '101': 'Switching Protocols', 采用不同的协议来完成这个请求
 '102': 'Processing',处理将被继续执行。
 '200': 'OK',请求已成功
 '201': 'Created',请求已经被实现，而且有一个新的资源已经依据请求的需要而建立，
 且其 URI 已经随Location 头信息返回
 '202': 'Accepted',服务器已接受请求，但尚未处理
 '203': 'Non-Authoritative Information',服务器已成功处理了请求，
 但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。
 当前的信息可能是原始版本的子集或者超集。例如，包含资源的元数据可能导致原始服务器知道元信息的超集。
 使用此状态码不是必须的，而且只有在响应不使用此状态码便会返回200 OK的情况下才是合适的。
 '204': 'No Content',服务器成功处理了请求，但不需要返回任何实体内容
 '205': 'Reset Content',
 服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。
 该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。
 '206': 'Partial Content',服务器已经成功处理了部分 GET 请求
 '207': 'Multi-Status',代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。
 '208': 'Already Reported',
 '226': 'IM Used',
 '300': 'Multiple Choices',被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。
 用户或浏览器能够自行选择一个首选的地址进行重定向。
 '301': 'Moved Permanently',
 被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一
 '302': 'Found',
 '303': 'See Other',
 '304': 'Not Modified',
 '305': 'Use Proxy',
 '307': 'Temporary Redirect',
 '308': 'Permanent Redirect',
 '400': 'Bad Request',语义有误， 请求参数有误
 '401': 'Unauthorized',当前请求需要用户验证
 '402': 'Payment Required',该状态码是为了将来可能的需求而预留的
 '403': 'Forbidden',服务器已经理解请求，但是拒绝执行它
 '404': 'Not Found',请求失败，请求所希望得到的资源未被在服务器上发现
 '405': 'Method Not Allowed',请求行中指定的请求方法不能被用于请求相应的资源
 '406': 'Not Acceptable',请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体
 '407': 'Proxy Authentication Required',代理服务器必须返回一个 Proxy-Authenticate 用以进行身份询问
 '408': 'Request Timeout',请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送
 '409': 'Conflict',由于和被请求的资源的当前状态之间存在冲突，请求无法完成
 '410': 'Gone',被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址
 '411': 'Length Required',服务器拒绝在没有定义 Content-Length 头的情况下接受请求
 '412': 'Precondition Failed',服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个
 '413': 'Payload Too Large',服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围
 '414': 'URI Too Long',请求的URI 长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务
 '415': 'Unsupported Media Type',对于当前请求的方法和所请求的资源，请求中提交的实体并不是服务器中所支持的格式，因此请求被拒绝。
 '416': 'Range Not Satisfiable',
 如果请求中包含了 Range 请求头，
 并且 Range 中指定的任何数据范围都与当前资源的可用范围不重合，
 同时请求中又没有定义 If-Range 请求头，那么服务器就应当返回416状态码。
 '417': 'Expectation Failed',
 在请求头 Expect 中指定的预期内容无法被服务器满足，或者这个服务器是一个代理服务器，
 它有明显的证据证明在当前路由的下一个节点上，Expect 的内容无法被满足。
 '418': 'I\'m a teapot',
 '421': 'Misdirected Request',
 '422': 'Unprocessable Entity',
 '423': 'Locked',
 '424': 'Failed Dependency',
 '425': 'Unordered Collection',
 '426': 'Upgrade Required',
 '428': 'Precondition Required',
 '429': 'Too Many Requests',
 '431': 'Request Header Fields Too Large',
 '451': 'Unavailable For Legal Reasons',
 '500': 'Internal Server Error',服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。
 一般来说，这个问题都会在服务器端的源代码出现错误时出现。
 '501': 'Not Implemented',服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求
 '502': 'Bad Gateway',作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。
 '503': 'Service Unavailable',由于临时的服务器维护或者过载，服务器当前无法处理请求。
 '504': 'Gateway Timeout',未能及时从上游服务器或者辅助服务器（例如DNS）收到响应
 '505': 'HTTP Version Not Supported',服务器不支持，或者拒绝支持在请求中使用的 HTTP 版本
 '506': 'Variant Also Negotiates',代表服务器存在内部配置错误
 '507': 'Insufficient Storage',服务器无法存储完成请求所必须的内容
 '508': 'Loop Detected',服务器在处理请求时发现一个无限循环
 '509': 'Bandwidth Limit Exceeded',服务器达到带宽限制。这不是一个官方的状态码，但是仍被广泛使用。
 '510': 'Not Extended',获取资源所需要的策略并没有被满足
 '511': 'Network Authentication Required' },